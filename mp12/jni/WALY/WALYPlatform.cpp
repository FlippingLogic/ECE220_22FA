//									tab:8
//
// WALYPlatform.cpp - source file for most platform-dependent WALY code
//
// "Copyright (c) 2012-2013 by Steven S. Lumetta."
//
// Permission to use, copy, modify, and distribute this software and its
// documentation for any purpose, without fee, and without written agreement is
// hereby granted, provided that the above copyright notice and the following
// two paragraphs appear in all copies of this software.
// 
// IN NO EVENT SHALL THE AUTHOR OR THE UNIVERSITY OF ILLINOIS BE LIABLE TO 
// ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL 
// DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, 
// EVEN IF THE AUTHOR AND/OR THE UNIVERSITY OF ILLINOIS HAS BEEN ADVISED 
// OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// THE AUTHOR AND THE UNIVERSITY OF ILLINOIS SPECIFICALLY DISCLAIM ANY 
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE 
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND NEITHER THE AUTHOR NOR
// THE UNIVERSITY OF ILLINOIS HAS ANY OBLIGATION TO PROVIDE MAINTENANCE, 
// SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
//
// Author:	    Steve Lumetta
// Version:	    1.07
// Creation Date:   23 December 2012
// Filename:	    WALYPlatform.cpp
// History:
//	SL	1.00	23 December 2012
//		First written.
//	SL	1.01	1 January 2013
//		Working on several platforms.
//	SL	1.02	3 January 2013
//		Removed some dead code and added orientation-handling.
//	SL	1.03	3 January 2013
//		Fixed minor SDL call ordering issue.
//	SL	1.04	5 January 2013
//		Added PNG RGB support.
//	SL	1.05	19 January 2013
//		Made stale window decor checks more aggressive in Android.
//	SL	1.06	28 January 2013
//		Added unistd.h for all platforms (instead of just Android).
//	SL	1.07	2 February 2013
//		Added support for allowing application to size the window.
//

#include "WALY.h"

#include <unistd.h>

using namespace std;

#if !defined(WALY_TARGET_ANDROID)
#include "SDL/SDL_image.h"
#else // defined(WALY_TARGET_ANDROID)
static int translateEvent (SDL_Event* evt, int timeout);
#endif // defined(WALY_TARGET_*)

namespace WALY_1_0_0 {

char* Platform::appName = NULL;
char* Platform::dirName = NULL;
char* Platform::visDirName = NULL;
#if defined(WALY_TARGET_ANDROID)
struct android_app* Platform::app = NULL;
JNIEnv* Platform::env = NULL;
jmethodID Platform::showKbdMethod = NULL;
jmethodID Platform::hideKbdMethod = NULL;
jmethodID Platform::minimizeMethod = NULL;
jmethodID Platform::getTopVisibleMethod = NULL;
jmethodID Platform::getBottomVisibleMethod = NULL;
bool Platform::kbdShown = false;
int32_t Platform::physScreenW = 0;
int32_t Platform::physScreenH = 0;
int32_t Platform::drawOffX = 0;
int32_t Platform::drawOffY = 0;
int32_t Platform::appRequestW = 0;
int32_t Platform::appRequestH = 0;
#include <sys/time.h>
static struct timeval appStart;
#include <android/log.h>
#include <android/input.h>
#include <png.h>
static uint8_t* readPNGAsset_worker (AAssetManager* mngr, const char* path,
				     png_structp png_ptr, png_infop info_ptr);
static Surface* readPNGAsset (AAssetManager* mngr, const char* path);
#endif // defined(WALY_TARGET_ANDROID)

Surface*
Platform::init (int32_t width, int32_t height)
{
    Surface* retVal = NULL;

#if !defined(WALY_TARGET_ANDROID)
    // initialize SDL
    //if (0 != SDL_Init (SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_JOYSTICK)) {
    if (0 != SDL_Init (SDL_INIT_VIDEO | SDL_INIT_AUDIO)) {
        // panic!
	throw std::exception ();
    }
#endif // !defined(WALY_TARGET_ANDROID)

#if defined(WALY_TARGET_WEBOS)
    // initialize PDL
    if (PDL_NOERROR != PDL_Init (0)) {
        // panic!
	SDL_Quit ();
	throw std::exception ();
    }
#endif // defined(WALY_TARGET_WEBOS)

#if defined(WALY_TARGET_WEBOS)
    // use full-screen video with native SDL
// FIXME : need to try setting screen size with webos!
    retVal = SDL_SetVideoMode (0, 0, 0, SDL_FULLSCREEN);
    if (NULL == retVal) {
        // panic!
	PDL_Quit ();
	SDL_Quit ();
	throw std::exception ();
    }
#elif defined(WALY_TARGET_CYGWIN)
    //
    // Note that SetIcon must be called before setting the video mode.
    // The same is true for SetCaption, although the docs didn't mention it.
    //
    (void)SDL_WM_SetCaption (APP_TITLE, APP_TITLE);
    // try...if it fails, that's ok.
    Surface* icon = IMG_Load ("icons/icon32.png");
    // Not supposed to use SDL_image; some weirdness whether we use
    // png or bitmap, though, so sticking with what we have for now... FIXME
    // Surface* icon = SDL_LoadBMP ("icons/icon32.bmp");
    if (NULL != icon) {
	SDL_WM_SetIcon (icon, NULL);
	SDL_FreeSurface (icon);
    }
    retVal = SDL_SetVideoMode (width, height, 32, SDL_SWSURFACE);
    if (NULL == retVal) {
        // panic!
	SDL_Quit ();
	throw std::exception ();
    }
#else // defined(WALY_TARGET_ANDROID)
    // for SDL_GetTicks
    (void)gettimeofday (&appStart, NULL);

    appRequestW = width;
    appRequestH = height;
    retVal = new Surface ();
    retVal->w = width;
    retVal->h = height;
    retVal->format = &retVal->sfmt;
    // oh, mask should depend on endianness...!
    retVal->format->Amask = 0;
    retVal->format->alpha = 255;
    // private rendering buffer for screen (width x height)
    retVal->pixels = malloc (4 * width * height);
    if (NULL == retVal->pixels) {
        delete retVal;
	throw std::exception ();
    }
    retVal->pitch = width * 4;
    retVal->clipRect.x = 0;
    retVal->clipRect.y = 0;
    retVal->clipRect.w = width;
    retVal->clipRect.h = height;
    // buffer should only be used between lock and unlock, so no init...
#endif // defined(WALY_TARGET_*)

#if defined(WALY_TARGET_WEBOS)
    {
        char name[1024];

	if (PDL_NOERROR != PDL_GetAppinfoValue ("title", name, 1024)) {
	    strcpy (name, "application");
	}
	appName = new char[strlen (name) + 1];
	strcpy (appName, name);

	if (PDL_NOERROR != PDL_GetDataFilePath ("a", name, 1024)) {
	    // writing here will fail, but...
	    strcpy (name, "./a");
	}
	int32_t len = strlen (name);
	name[len - 1] = '\0'; // remove the 'a'
	dirName = new char[len];
	strcpy (dirName, name);

	const char* vdName = "/media/internal/downloads/";
	visDirName = new char[strlen (vdName) + 1];
	strcpy (visDirName, vdName);
    }
#elif defined(WALY_TARGET_CYGWIN)
    {
	// compile-time constant
	const char* name = APP_NAME;
	appName = new char[strlen (name) + 1];
	strcpy (appName, name);

	const char* storeName = "storage/";
	dirName = new char[strlen (storeName) + 1];
	strcpy (dirName, storeName);

	const char* debugName = "debug/";
	visDirName = new char[strlen (debugName) + 1];
	strcpy (visDirName, debugName);
    }
#else // defined(WALY_TARGET_ANDROID)
// must wait until we have an app pointer--this 
// code is called before that point
#endif // defined(WALY_TARGET_*)

    return retVal;
}

void
Platform::terminate ()
{
#if defined(WALY_TARGET_WEBOS)
    PDL_Quit ();
#endif // defined(WALY_TARGET_WEBOS)

#if !defined(WALY_TARGET_ANDROID)
    SDL_Quit ();
#endif

    delete[] appName;
    delete[] dirName;
    delete[] visDirName;
}

Surface*
Platform::IMG_Load (const char* fname)
{
#if !defined(WALY_TARGET_ANDROID)
    return ::IMG_Load (fname);
#else // defined(WALY_TARGET_ANDROID)
    return readPNGAsset (Platform::getApp ()->activity->assetManager, fname);
#endif
}

void
Platform::minimize ()
{
#if defined(WALY_TARGET_WEBOS)
    (void)PDL_Minimize ();
#elif defined(WALY_TARGET_CYGWIN)
    (void)SDL_WM_IconifyWindow ();
#else //defined(WALY_TARGET_ANDROID)
    env->CallVoidMethod (app->activity->clazz, minimizeMethod);
#endif //defined(WALY_TARGET_*)
}


bool
Platform::pollEvent (int32_t msec, Event* evt)
{
#if defined(WALY_TARGET_WEBOS)
    if (-1 == msec) {
        SDL_WaitEvent (evt);
	return true;
    }
    return (0 != SDL_PollEvent (evt));
#elif defined(WALY_TARGET_CYGWIN)
    // Cygwin has some kind of synchronization error with wait and
    // window minimization.  If you call wait when the user minimizes,
    // the call never returns (even after they try to pop the window up).
    // So we have to do a workaround.
    if (-1 == msec) {
	while (1) {
	    if (0 != SDL_PollEvent (evt)) {
		return true;
	    }
	    usleep (100);
	}
    }
    return (0 != SDL_PollEvent (evt));
#else // defined(WALY_TARGET_ANDROID)
    if (-1 == msec) {
	while (0 == translateEvent (evt, -1)) { }
	return true;
    }
    return (0 != translateEvent (evt, msec));
#endif // defined(WALY_TARGET_*)
}


} // end of namespace WALY_1_0_0





#if defined(WALY_TARGET_ANDROID)

//
// SDL stub calls for Android; have to go here because of Android's
// rather odd way of linking with their native glue...
//

using namespace WALY;

// used for post-processing callback
static int32_t waiting_android_input_id;
static int waiting_android_cmd;
static AInputEvent* waiting_android_input_evt;
static uint32_t cachedScreenW = 10;
static uint32_t cachedScreenH = 10;
static uint32_t cachedUseW = 10;
static uint32_t cachedUseH = 10;
static double cachedScale = 1.0;

static int32_t
mapKey (int32_t android, SDLMod mod)
{
    /* map android key codes into SDL key codes... */

    if (AKEYCODE_A <= android && AKEYCODE_Z >= android) {
        return (android - AKEYCODE_A + 'a');
    }
    if (AKEYCODE_0 <= android && AKEYCODE_9 >= android) {
	if (0 != (KMOD_SHIFT & mod)) {
	    return ")!@#$%^&*("[android - AKEYCODE_0];
	}
        return (android - AKEYCODE_0 + '0');
    }
    switch (android) {
//      case AKEYCODE_BACK:          the hard 'back' key on Android
	case AKEYCODE_DEL:           return SDLK_BACKSPACE;
        case AKEYCODE_TAB:           return SDLK_TAB;
        case AKEYCODE_SPACE:         return SDLK_SPACE;
        case AKEYCODE_ENTER:         return SDLK_RETURN;
	case AKEYCODE_COMMA:
	    return (0 != (KMOD_SHIFT & mod) ? '<' : ',');
	case AKEYCODE_PERIOD:
	    return (0 != (KMOD_SHIFT & mod) ? '>' : '.');
	case AKEYCODE_MINUS:
	    return (0 != (KMOD_SHIFT & mod) ? '_' : '-');
	case AKEYCODE_EQUALS:
	    return (0 != (KMOD_SHIFT & mod) ? '+' : '=');
	case AKEYCODE_LEFT_BRACKET:
	    return (0 != (KMOD_SHIFT & mod) ? '{' : '[');
	case AKEYCODE_RIGHT_BRACKET:
	    return (0 != (KMOD_SHIFT & mod) ? '}' : ']');
	case AKEYCODE_BACKSLASH:
	    return (0 != (KMOD_SHIFT & mod) ? '|' : '\\');
	case AKEYCODE_SEMICOLON:
	    return (0 != (KMOD_SHIFT & mod) ? ':' : ';');
	case AKEYCODE_APOSTROPHE:
	    return (0 != (KMOD_SHIFT & mod) ? '\"' : '\'');
	case AKEYCODE_SLASH:
	    return (0 != (KMOD_SHIFT & mod) ? '?' : '/');
	case AKEYCODE_GRAVE:
	    return (0 != (KMOD_SHIFT & mod) ? '~' : '`');
	default: return SDLK_UNKNOWN;
    }
}

//
// oh, joy is me.  ANOTHER Android workaround!
//
// It seems that when the ONLY event one receives on an orientation
// change (CONFIG_CHANGED) occurs, Android is ***sometimes*** not quite
// ready with the new decoration sizes.  Synchronization is hard, you
// know?  Tough thing to get right.  Anyway, we can identify the problem,
// make a guess as to the right answers, and then try again on the next 
// event...
//

static bool androidDecorIsStale = false;

static void
setScreenMapping ()
{
    android_app* app = Platform::getApp ();
    int32_t screenW;
    int32_t screenH;
    int32_t top;
    int32_t bottom;
    int32_t desiredW;
    int32_t desiredH;

    Platform::getRequestedDims (&desiredW, &desiredH);
    Platform::getScreenDims (&screenW, &screenH, &top, &bottom);

    // assume portrait or landscape... treat square as landscape
    if (ACONFIGURATION_ORIENTATION_PORT ==
	AConfiguration_getOrientation (app->config)) {
	cachedScreenW = screenW;
	cachedScreenH = screenH;
    } else {
	cachedScreenW = screenH;
	cachedScreenH = screenW;
    }

    if (0 > cachedScreenH - bottom || 100 < cachedScreenH - bottom) {
        // oops.  stale.
	androidDecorIsStale = true;
	// 'guess' based on Nexus 7
	top = 33;
	if (ACONFIGURATION_ORIENTATION_PORT ==
	    AConfiguration_getOrientation (app->config)) {
	    bottom = cachedScreenH - 75;
	} else {
	    bottom = cachedScreenH - 64;
	}
    } else {
	androidDecorIsStale = false;
    }
    // need to ensure exposure when we're called again...
    // (can go away if Android ever fixes this issue)
    Rect r;
    r.x = r.y = 0;
    r.w = desiredW;
    r.h = desiredH;
    ((Screen*)Screen::getRootFrame ())->expose (r);

    double xFactor = desiredW / (double)cachedScreenW; 
    double yFactor = desiredH / (double)(bottom - top);

    if (xFactor <= yFactor) {
	cachedScale = yFactor;
    } else {
	cachedScale = xFactor;
    }

    // we don't try to center in vertical dimension...
    int32_t drawOffX = (int32_t)
	    ((cachedScreenW * cachedScale - desiredW) / 2 + 0.5);
    int32_t drawOffY = (int32_t)(top * cachedScale + 0.5);
    Platform::setDrawingOffset (drawOffX, drawOffY);

    cachedUseW = 2 * drawOffX + desiredW;
    // scaling is done to bottom, not phys. screen size
    cachedUseH = drawOffY + desiredH;

    ANativeWindow_setBuffersGeometry (app->window, cachedUseW, cachedUseH,
				      WINDOW_FORMAT_RGBX_8888);
}

static int 
translateEvent (SDL_Event* evt, int timeout)
{
    int32_t ident;
    int32_t events;
    struct android_poll_source* src;

    ident = ALooper_pollAll (timeout, NULL, &events, (void**)&src);
    if (0 >= ident || NULL == src) {
	// explanation at variable declaration above...
	if (androidDecorIsStale) {
	    setScreenMapping ();
	}

        return 0;
    }

    // translate Android events to SDLstub events...

    //
    // ARGH!  Why does Android make user do its processing!?
    // I will have to add a callback for postprocessing...
    // I won't bother to make it thread-safe--only one event loop
    // in WALY...
    //
    android_app* app = Platform::getApp ();
    waiting_android_input_id = src->id;
    if (LOOPER_ID_MAIN == src->id) {
        int8_t cmd = android_app_read_cmd (app);

	android_app_pre_exec_cmd (app, cmd);

	// 
	// We will start/stop app on INIT_WINDOW/PAUSE events
	// (Android delivers GAIN_FOCUS after INIT_WINDOW when
	// starting, but ... no matter; PAUSE is the first in
	// the sequence for stopping...APP should save state
	// at that point, so we will send !APPACTIVE in SDL
	// terms)
	//
	// Also, surface/window only available in Android from
	// INIT_WINDOW until TERM_WINDOW (latter is after PAUSE)
	//
	// Actually, since Android just expects apps to sleep
	// and doesn't reliably deliver any termination events, ...
	// I guess we just have to avoid passing up SDL_QUIT at all.
	//
	waiting_android_cmd = cmd;
	switch (cmd) {
	    case APP_CMD_INIT_WINDOW:
		Screen::setWindow (app->window);
	    	setScreenMapping ();
	        evt->type = SDL_ACTIVEEVENT;
		evt->active.gain = 1;
		evt->active.state = SDL_APPACTIVE;
	        return 1;

	    case APP_CMD_CONFIG_CHANGED:
		// occurs when screen orientation is changed
	        setScreenMapping ();
		evt->type = SDL_VIDEOEXPOSE;
	        return 1;

	    case APP_CMD_WINDOW_RESIZED:
	    case APP_CMD_WINDOW_REDRAW_NEEDED:
	    case APP_CMD_CONTENT_RECT_CHANGED:
	    	// have never seen these events
		evt->type = SDL_VIDEOEXPOSE;
		return 1;

	    case APP_CMD_GAINED_FOCUS:
	        evt->type = SDL_ACTIVEEVENT;
		evt->active.gain = 1;
		evt->active.state = (SDL_APPINPUTFOCUS | SDL_APPMOUSEFOCUS);
	        return 1;

	    case APP_CMD_LOST_FOCUS:
	        evt->type = SDL_ACTIVEEVENT;
		evt->active.gain = 0;
		evt->active.state = (SDL_APPINPUTFOCUS | SDL_APPMOUSEFOCUS);
	        return 1;

	    case APP_CMD_PAUSE:
	        evt->type = SDL_ACTIVEEVENT;
		evt->active.gain = 0;
		evt->active.state = SDL_APPACTIVE;
	        return 1;

	    case APP_CMD_DESTROY:
	        evt->type = SDL_QUIT;
		return 1;

	    case APP_CMD_STOP:
#if 0 // see discussion above
	        evt->type = SDL_QUIT;
		return 1;
#endif // fall through to ignored events
	    case APP_CMD_INPUT_CHANGED:
	    case APP_CMD_TERM_WINDOW:
	    case APP_CMD_LOW_MEMORY:
	    case APP_CMD_START:
	    case APP_CMD_RESUME:	
	    case APP_CMD_SAVE_STATE:
		// one comment on these: save/restore state didn't seem
		// to actually work on Nexus 7: I saved data, but it never
		// came back; need to use filesystem for reliable and
		// uniform behavior
		// Do the post-processing for these now...
		android_app_post_exec_cmd (app, cmd);
	    	return 0;

	    default:  // (report no warning for known commands)
		__android_log_print (ANDROID_LOG_INFO, "WALY",
				     "unknown Android command %d", cmd);
		// Do the post-processing for these now...
		android_app_post_exec_cmd (app, cmd);
	    	return 0;
	}
    } else {
	// input events...
	static AInputEvent* e;

	if (0 > AInputQueue_getEvent (app->inputQueue, &e)) {
	    return 0;
	}

	//
	// "preDispatch" fails to handle soft keyboard down requests...
	// bunch of flaky crap.  Will have to move it into individual cases.
	//

	waiting_android_input_evt = e;

	switch (AInputEvent_getType (e)) {
	    case AINPUT_EVENT_TYPE_KEY:
		int32_t key;

		evt->key.keysym.mod = (SDLMod)AKeyEvent_getMetaState (e);
		key = AKeyEvent_getKeyCode (e);
		evt->key.keysym.sym = 
			(SDLKey)mapKey (key, evt->key.keysym.mod);

		// We control the (hard) back button behavior...
		if (AKEYCODE_BACK == key) {
		    if (Platform::keyboardShown ()) {
			//
			// Ok, so ...
			//     we see 1+ down on back button
			//     and 1 up on release
			//     user may also drag to pull up other 
			//         apps (Google)
			//
			// NA will return true and then false from preDispatch
			//     for downs (it stays in the queue and shows up
			//     again).
			//
			// When we call postDispatch, if we say we have 
			//     handled, NA will do nothing else.  Also, for 
			//     downs, NA does nothing else.
			//
			// For up, if you tell NA that it's not handled, NA 
			//     will terminate the app.  (That's the 'back' to 
			//     previous app behavior...)  We'll get the usual
			//     command sequence, so no need to special case 
			//     here.
			//

			//
			// I'm going to wait for the key release to hide the
			// keyboard.  Here's why: (1) match the behavior of
			// the rest of the keys; (2) we get two "down" and
			// one "up" if the user holds the key.  
			//
			// Actually, I guess Android wants that sequence to
			// mean something different, but 'back' kills the app,
			// so ... no.  Push it again.
			//

			// Er...no.  When the keyboard is up, NA's preDispatch
			// chokes and dies.  No dice.  We'll call it but ignore
			// its claim of handling...
			//
			// NA will spit whiny error messages about not being
			// able to find the event in finishEvent, but if we
			// *don't* call finishEvent, it hangs...
			// (and if we say we didn't handle event, it kills app
			//   without commands!?!?!)
			//
			// Sigh.  Ok, we have to just ignore the predispatch.
			// It causes other flakiness, too, and things seem more
			// robust if we don't call at all...
			//
			// flakiness: might be hard to reproduce given that I'm
			// going to change behavior, but... click on entry box,
			// type, press return (entry box hides), then type
			// some more (I'm going to make keyboard vanish now...)
			// press enter again, then press 'back' (hard),
			// if you call predispatch for this seq, app will 
			// hang...
			//
			//(void)AInputQueue_preDispatchEvent (app->inputQueue, e);
			//
			if (AKEY_EVENT_ACTION_UP == AKeyEvent_getAction (e)) {
			    Platform::hideKeyboard ();
			}
			AInputQueue_finishEvent (app->inputQueue, e, true);
			return 0;
		    }

		    // no keyboard...let's handle BACK all the time, though,
		    // and leave it to app to do the right thing (call 
		    // minimize--maybe we'll just change to pause instead of
		    // killing)
		    if (AInputQueue_preDispatchEvent (app->inputQueue, e)) {
		        return 0;
		    }

		    evt->key.keysym.sym = PDLK_GESTURE_BACK;
		    switch (AKeyEvent_getAction (e)) {
			case AKEY_EVENT_ACTION_DOWN:
			    evt->type = SDL_KEYDOWN;
			    return 1;
			case AKEY_EVENT_ACTION_UP:
			    evt->type = SDL_KEYUP;
			    return 1;
		        default:
			    break;
		    }
		    WALYFinishEvent ();
		}

		// NOT safe to interfere with back key processing (above)
		if (0 != AKeyEvent_getRepeatCount (e)) {
		    __android_log_print (ANDROID_LOG_INFO, "WALY", 
		    		         "key repeat count %d (ignored)",
					 AKeyEvent_getRepeatCount (e));
		    if (!AInputQueue_preDispatchEvent (app->inputQueue, e)) {
			WALYFinishEvent ();
		    }
		    return 0;
		}

		switch (AKeyEvent_getAction (e)) {
		    case AKEY_EVENT_ACTION_DOWN:
			evt->type = SDL_KEYDOWN;
			if (!AInputQueue_preDispatchEvent 
			    (app->inputQueue, e)) {
			    return 1;
			}
			return 0;
		    case AKEY_EVENT_ACTION_UP:
			evt->type = SDL_KEYUP;
			if (!AInputQueue_preDispatchEvent 
			    (app->inputQueue, e)) {
			    return 1;
			}
			return 0;
		    default: // MULTIPLE ... no
		    	//
			// the smiley comes this way... check for it...
			// ... use it in place of the undelivered backspace!
			// (idiots.)
			//
			// we only get one...hopefully a 'down'
			// will do--don't want to bother faking it
			//
			if (0 == AKeyEvent_getFlags (e) &&
			    0 == AKeyEvent_getKeyCode(e) &&
			    0 == AKeyEvent_getScanCode (e) &&
			    0 == AKeyEvent_getMetaState (e) &&
			    0 == AKeyEvent_getRepeatCount (e)) {
			    evt->type = SDL_KEYDOWN;
			    evt->key.keysym.sym = SDLK_BACKSPACE;
			    return 1;
			}
			__android_log_print (ANDROID_LOG_INFO, "WALY",
					     "Android MULTIPLE key event");
			break;
		}
		if (!AInputQueue_preDispatchEvent (app->inputQueue, e)) {
		    WALYFinishEvent ();
		}
		return 0;
	    case AINPUT_EVENT_TYPE_MOTION: {
		if (AInputQueue_preDispatchEvent (app->inputQueue, e)) {
		    return 0;
		}

		int32_t bitsmash = AMotionEvent_getAction (e);
		int32_t action = (bitsmash & AMOTION_EVENT_ACTION_MASK);
		int32_t which = (bitsmash >> 
				 AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT);
		which = AMotionEvent_getPointerId (e, which);
		if (SDL_MAXMOUSE <= which) {
		    // squash it.
		    __android_log_print (ANDROID_LOG_INFO, "WALY",
					 "too many pointers!");
		    WALYFinishEvent ();
		    return 0;
		}
		int32_t drawOffX;
		int32_t drawOffY;
		Platform::getDrawingOffset (&drawOffX, &drawOffY);
		int32_t x = (int)(cachedScale * AMotionEvent_getRawX
				  (e, which) + 0.5) - drawOffX;
		int32_t y = (int)(cachedScale * AMotionEvent_getRawY
				  (e, which) + 0.5) - drawOffY;

		switch (action) {
		    case AMOTION_EVENT_ACTION_DOWN:
		    case AMOTION_EVENT_ACTION_POINTER_DOWN:
			evt->type = SDL_MOUSEBUTTONDOWN;
			evt->button.which = which;
			evt->button.x = x;
			evt->button.y = y;
			return 1;
		    case AMOTION_EVENT_ACTION_UP:
		    case AMOTION_EVENT_ACTION_POINTER_UP:
			evt->type = SDL_MOUSEBUTTONUP;
			evt->button.which = which;
			evt->button.x = x;
			evt->button.y = y;
			return 1;
		    case AMOTION_EVENT_ACTION_MOVE:
			evt->type = SDL_MOUSEMOTION;
			evt->motion.which = which;
			evt->motion.x = x;
			evt->motion.y = y;
			return 1;
		    default:
			__android_log_print (ANDROID_LOG_INFO, "WALY",
					     "unknown Android motion type %d",
					     action);
			WALYFinishEvent ();
			return 0;
		}
	    }
	    default:
		__android_log_print (ANDROID_LOG_INFO, "WALY",
				     "unknown Android input event type %d",
				     AInputEvent_getType (e));
		if (!AInputQueue_preDispatchEvent (app->inputQueue, e)) {
		    WALYFinishEvent ();
		}
		return 0;
	}
    }

    return 0; 
}

void 
WALYFinishEvent ()
{
    if (LOOPER_ID_MAIN == waiting_android_input_id) {
	if (APP_CMD_PAUSE == waiting_android_cmd) {
	    //
	    // I'm a little wary of the Android event sequence...
	    // undocumented as it is.  PAUSE/RESUME could theoretically
	    // be issued without tearing down the window... they
	    // AREN'T now, but ...
	    //
	    // oh well...  that's why people use ... documentation!
	    //
	    Platform::hideKeyboard ();
	    Screen::clearWindow ();
	}
	android_app_post_exec_cmd (Platform::getApp (), waiting_android_cmd);
    } else {
    	// input events...
	bool handled = (AINPUT_EVENT_TYPE_KEY == AInputEvent_getType
				(waiting_android_input_evt) &&
			AKEYCODE_BACK == AKeyEvent_getKeyCode 
				(waiting_android_input_evt));
	AInputQueue_finishEvent (Platform::getApp ()->inputQueue,
				 waiting_android_input_evt, handled);
    }
}

void 
SDL_GetClipRect (SDL_Surface* s, SDL_Rect* r) { 
    *r = s->clipRect;
}

SDL_bool 
SDL_SetClipRect (SDL_Surface* s, const SDL_Rect* r) {
    s->clipRect.x = 0;
    s->clipRect.y = 0;
    s->clipRect.w = s->w;
    s->clipRect.h = s->h;
    return (NULL == r || Frame::intersect (r, &s->clipRect) ? 
    	    SDL_TRUE : SDL_FALSE);
}

uint32_t 
SDL_GetTicks () 
{
    struct timeval now;

    gettimeofday (&now, NULL);

    if (now.tv_usec < appStart.tv_usec) {
	return ((now.tv_sec - appStart.tv_sec) * 1000 -
		(appStart.tv_usec - now.tv_usec) / 1000);
    }
    return ((now.tv_sec - appStart.tv_sec) * 1000 +
	    (now.tv_usec - appStart.tv_usec) / 1000);
}

int 
SDL_FillRect (SDL_Surface* s, SDL_Rect* r, uint32_t color) 
{
    SDL_Rect fill = s->clipRect;

    if (NULL != r && !Frame::intersect (r, &fill)) {
        return 0;
    }
    uint32_t* pix = (uint32_t*)(((uint8_t*)s->pixels) + fill.y * s->pitch +
    			        fill.x * 4);
    for (int32_t y = 0; fill.h > y; y++) {
	for (int32_t x = 0; fill.w > x; x++) {
	    pix[x] = color;
	}
	pix = (uint32_t*)(((uint8_t*)pix) + s->pitch);
    }

    return 0; 
}

void 
SDL_BlitSurface (SDL_Surface* src, SDL_Rect* srcrect,
		 SDL_Surface* dst, SDL_Rect* dstrect) 
{
    SDL_Rect from;
    SDL_Rect to;

    from.x = from.y = 0;
    from.w = src->w;
    from.h = src->h;
    if (NULL != srcrect) {
	(void)Frame::intersect (srcrect, &from);
    }

    to.x = dstrect->x;
    to.y = dstrect->y;
    to.w = from.w;
    to.h = from.h;
    (void)Frame::intersect (&dst->clipRect, &to);

    from.x += to.x - dstrect->x;
    from.y += to.y - dstrect->y;
    from.w = to.w;
    from.h = to.h;

    if (0 == from.w || 0 == from.h) {
        to.x = to.y = to.w = to.h = 0;
    }
    *dstrect = to;

    if (0 < from.w) {
        uint32_t* spix = (uint32_t*)(((uint8_t*)src->pixels) + 
				     from.y * src->pitch + from.x * 4);
        uint32_t* dpix = (uint32_t*)(((uint8_t*)dst->pixels) + 
				     to.y * dst->pitch + to.x * 4);
	
	if (0 == src->format->Amask && 255 == src->format->alpha) {
	    for (int32_t y = 0; from.h > y; y++) {
		for (int32_t x = 0; from.w > x; x++) {
		    dpix[x] = spix[x];
		}
		spix = (uint32_t*)(((uint8_t*)spix) + src->pitch);
		dpix = (uint32_t*)(((uint8_t*)dpix) + dst->pitch);
	    }
	} else {
	    for (int32_t y = 0; from.h > y; y++) {
		for (int32_t x = 0; from.w > x; x++) {
		    uint32_t sval = spix[x];
		    uint32_t amt;

		    // alpha is high bits for Android ARM native window
		    // ...emulator too?
// ENDIANNESS
		    amt = (0 == src->format->Amask ?
		    	   src->format->alpha : (sval >> 24));
		    if (255 == amt) {
			dpix[x] = sval;
		    } else {
			uint32_t dval = dpix[x];
			uint32_t bck = 256 - amt;
			uint32_t red = 
			    ((amt * (sval & 0xFF) + bck * (dval & 0xFF)) >> 8);
			uint32_t green = 
			    (((amt * (sval & 0xFF00) + 
			      bck * (dval & 0xFF00)) >> 8) & 0xFF00);
			uint32_t blue = 
			    (((amt * (sval & 0xFF0000) + 
			      bck * (dval & 0xFF0000)) >> 8) & 0xFF0000);
			dpix[x] = (0xFF000000 | blue | green | red);
		    }
		}
		spix = (uint32_t*)(((uint8_t*)spix) + src->pitch);
		dpix = (uint32_t*)(((uint8_t*)dpix) + dst->pitch);
	    }
	}
    }
}

//
// called, but rendering style of WALY under Android makes it a nop
//
void 
SDL_UpdateRect (SDL_Surface* s, int32_t x, int32_t y, 
		uint32_t w, uint32_t h) { }

void 
SDL_FreeSurface (SDL_Surface* s) 
{
    if (NULL != s->pixels) {
        free (s->pixels);
    }
    delete s;
}

SDL_Surface* 
SDL_CreateRGBSurface (uint32_t flags, int width, int height, int depth, 
		      uint32_t Rmask, uint32_t Gmask, uint32_t Bmask, 
		      uint32_t Amask)
{
    SDL_Surface* s;

    if (NULL == (s = new Surface ())) {
        return NULL;
    }
    if (NULL == (s->pixels = malloc (4 * width * height))) {
	delete s;
	return NULL;
    }
    // not sure if SDL semantics require, but my code assumes
    // (so other SDL implementations must...)
    memset (s->pixels, 0, 4 * width * height); 
    s->w = width;
    s->h = height;
    s->format = &s->sfmt;
    // oh, mask should depend on endianness...!
    // ENDIANNESS
    s->format->Amask = 0xFF000000;
    s->format->alpha = 255;
    // s->pixels = ...   <-- allocated above
    s->pitch = s->w * 4;
    s->clipRect.x = 0;
    s->clipRect.y = 0;
    s->clipRect.w = s->w;
    s->clipRect.h = s->h;
    // buffer should never be used for images, so no init...

    return s;
}

int 
SDL_SetAlpha (SDL_Surface* s, uint32_t flag, uint8_t alpha) 
{
    // hack...only way used by widgets...
    s->format->Amask = 0;
    s->format->alpha = 255;
    return 0;
}


// locking/unlocking surfaces...

// 
// We don't have any access to Android native windows other than through
// locking (no hardware support is exposed through this interface, I guess?)
// 
// hopefully that's not crippling to performance
//
// Anyway, what we'll do is lock/unlock around full render (elsewhere).
//
// That means that SDL locking, which need not happen on images, does not
// need to be handled at all...
//
SDL_bool SDL_MUSTLOCK (SDL_Surface* s) { return SDL_FALSE; }
int SDL_LockSurface (SDL_Surface* s) { return -1; }
void SDL_UnlockSurface (SDL_Surface* s) { }


// TTF calls (true type fonts)

////  START OF FONT DATA
static const uint8_t fontData[4096] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD,
    0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3,
    0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE,
    0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE,
    0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7,
    0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF,
    0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C,
    0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3,
    0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42,
    0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD,
    0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC,
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C,
    0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30,
    0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63,
    0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7,
    0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8,
    0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E,
    0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
    0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B,
    0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6,
    0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
    0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE,
    0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE,
    0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0,
    0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE,
    0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C,
    0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C,
    0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C,
    0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06,
    0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18,
    0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF,
    0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E,
    0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18,
    0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30,
    0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE,
    0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06,
    0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18,
    0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06,
    0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60,
    0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,
    0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06,
    0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18,
    0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE,
    0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66,
    0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE,
    0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78,
    0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60,
    0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C,
    0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6,
    0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38,
    0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30,
    0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38,
    0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66,
    0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78,
    0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6,
    0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66,
    0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60,
    0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30,
    0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66,
    0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6,
    0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38,
    0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18,
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18,
    0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18,
    0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6,
    0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0,
    0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0x00, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60,
    0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE,
    0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6,
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6,
    0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C,
    0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36,
    0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x00, 0x00, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    0x00, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x60,
    0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60,
    0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
    0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE,
    0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18,
    0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE,
    0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60,
    0xC0, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0,
    0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06,
    0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30,
    0x60, 0xDC, 0x86, 0x0C, 0x18, 0x3E, 0x00, 0x00,
    0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30,
    0x66, 0xCE, 0x9E, 0x3E, 0x06, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18,
    0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6C, 0xD8,
    0x6C, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x6C, 0x36,
    0x6C, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
    0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8,
    0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0xCC,
    0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0,
    0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C,
    0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18,
    0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8,
    0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66,
    0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66,
    0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE,
    0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C,
    0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66,
    0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB,
    0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x06, 0x7E, 0xDB, 0xDB,
    0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60,
    0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6,
    0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE,
    0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18,
    0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C,
    0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30,
    0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E,
    0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00,
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC,
    0x6C, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x70, 0xD8, 0x30, 0x60, 0xC8, 0xF8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C,
    0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
////  END OF FONT DATA

int 
TTF_SizeText (TTF_Font* font, const char* text, int* w, int* h)
{
    int32_t ptSize = *font;
    int32_t len = strlen (text);

    *w = ptSize * len / 2;
    *h = ptSize;
    return 0;
}

SDL_Surface* 
TTF_RenderText_Blended (TTF_Font* font, const char* text, SDL_Color fg)
{
    int32_t ptSize = *font;
    int32_t len = strlen (text);
    SDL_Surface* s;
    int width;
    int height;
    uint32_t* img;

    if (NULL == (s = new Surface ())) { 
	return NULL; 
    }

    width = len * ptSize / 2;
    height = ptSize;

    if (NULL == (img = (uint32_t*)malloc (4 * width * height))) {
	delete s;
	return NULL;
    }

    // prepare the new surface...
    s->w = width;
    s->h = height;
    s->format = &s->sfmt;
    // oh, mask should depend on endianness...!
// ENDIANNESS
    s->format->Amask = 0xFF000000;
    s->format->alpha = 255;
    s->pixels = img;
    s->pitch = s->w * 4;
    s->clipRect.x = 0;
    s->clipRect.y = 0;
    s->clipRect.w = s->w;
    s->clipRect.h = s->h;
    // buffer should never be used for images, so no init...

    int32_t xScale, yScale;
    int32_t xOff, yOff;
    uint32_t alpha;

    // now it's time to draw the letters...
    // use alpha for edge shading?  mmm...
    uint32_t c = ((fg.b << 16) | (fg.g << 8) | fg.r);
    yScale = 0;
    yOff = 0;
    for (int32_t y = 0; height > y; y++) {
	if (ptSize <= yScale) {
	    yScale -= ptSize;
	    yOff++;
	}
	xScale = 0;
	xOff = 0;
	for (int32_t x = 0; width > x; x++) {
	    if (ptSize <= xScale) {
	        xScale -= ptSize;
		xOff++;
	    }
	    alpha = 0;
	    // four cases are possible...
	    if (ptSize < yScale + 16) {
		if (ptSize < xScale + 16) {
		    // spans 4 pixels
		    if (0 != (fontData[(text[xOff >> 3] << 4) + yOff] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += (ptSize - xScale) * (ptSize - yScale);
		    }
		    if (0 != (fontData[(text[(xOff + 1) >> 3] << 4) + yOff] &
		    	(1UL << (7 - ((xOff + 1) & 7))))) {
			alpha += (xScale + 16 - ptSize) * (ptSize - yScale);
		    }
		    if (0 != (fontData[(text[xOff >> 3] << 4) + (yOff + 1)] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += (ptSize - xScale) * (yScale + 16 - ptSize);
		    }
		    if (0 != (fontData[(text[(xOff + 1) >> 3] << 4) +
		    	(yOff + 1)] & (1UL << (7 - ((xOff + 1) & 7))))) {
			alpha += (xScale + 16 - ptSize) * 
				 (yScale + 16 - ptSize);
		    }
		} else {
		    // spans 2 vertical pixels
		    if (0 != (fontData[(text[xOff >> 3] << 4) + yOff] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += 16 * (ptSize - yScale);
		    }
		    if (0 != (fontData[(text[xOff >> 3] << 4) + (yOff + 1)] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += 16 * (yScale + 16 - ptSize);
		    }
		}
	    } else {
		if (ptSize < xScale + 16) {
		    // spans 2 horizontal pixels
		    if (0 != (fontData[(text[xOff >> 3] << 4) + yOff] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += (ptSize - xScale) * 16;
		    }
		    if (0 != (fontData[(text[(xOff + 1) >> 3] << 4) + yOff] &
		    	(1UL << (7 - ((xOff + 1) & 7))))) {
			alpha += (xScale + 16 - ptSize) * 16;
		    }
		} else {
		    // contained within 1 pixel
		    if (0 != (fontData[(text[xOff >> 3] << 4) + yOff] &
		    	(1UL << (7 - (xOff & 7))))) {
			alpha += 256;
		    }
		}
	    }
	    img[x] = ((((255 * alpha) & 0xFF00) << 16) | c);
	    xScale += 16;
	}
	img += width;
	yScale += 16;
    }
    return s;
}

int 
TTF_FontLineSkip (const TTF_Font* font)
{
    int32_t ptSize = *font;
    // put here instead of in header to make it easier to find...
    return (5 * ptSize / 4);
}



namespace WALY_1_0_0 {

///
/// file scope functions for image loading in Android
///

/* Hmm...not thread-safe...not sure how I want to handle these, though... */

/* libPNG structures; nexus 7 is 800x1280, so we'll just limit #rows to 
   2048 to save a little time... */
#define MAX_PNG_HEIGHT 2048
static png_bytep row_pointers[MAX_PNG_HEIGHT];

static uint8_t*
readPNGAsset_worker (AAssetManager* mngr, const char* path,
		     png_structp png_ptr, png_infop info_ptr)
{
    AAsset* asset = AAssetManager_open (mngr, path, AASSET_MODE_STREAMING);

    if (NULL == asset) {
	return NULL;
    }

    off_t os, ol;
    int ofd = AAsset_openFileDescriptor (asset, &os, &ol);
    // sample code (native-audio) handles this way... I guess it's safe?
    AAsset_close (asset);
    if (0 > ofd) {
	return NULL;
    }

    FILE* f;
    char buf[8];
    if (os != lseek (ofd, os, SEEK_SET) ||
        NULL == (f = fdopen (ofd, "rb")) ||
	1 != fread (buf, 8, 1, f)) {
	close (ofd);
	return NULL;
    }

    if (0 != png_sig_cmp ((png_bytep)buf, 0, 8)) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", "%s not a PNG file",
			     path);
	fclose (f);
	return NULL;
    }

    png_init_io (png_ptr, f);
    png_set_sig_bytes (png_ptr, 8);

#if 0
    int code;
    if (0 != (code = setjmp (png_jmpbuf (png_ptr)))) {
	__android_log_print (ANDROID_LOG_INFO, "WALY",  "%s longjmp %d", 
			     path, code);
	fclose (f);
	return NULL;
    }
#endif

    png_read_info (png_ptr, info_ptr);

    /* We only allow non-interlaced, 32-bit RGBA color PNGs. */
    int32_t colorType = png_get_color_type (png_ptr, info_ptr);
    int32_t numChannels = png_get_channels (png_ptr, info_ptr);

    if (8 != png_get_bit_depth (png_ptr, info_ptr) ||
	((PNG_COLOR_TYPE_RGB  != colorType || 3 != numChannels) &&
	 (PNG_COLOR_TYPE_RGBA != colorType || 4 != numChannels)) ||
	PNG_FILTER_TYPE_BASE != png_get_filter_type (png_ptr, info_ptr) ||
	PNG_COMPRESSION_TYPE_BASE != 
		png_get_compression_type (png_ptr, info_ptr) ||
	PNG_INTERLACE_NONE != png_get_interlace_type (png_ptr, info_ptr)) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", 
			     "%s disallowed PNG type", path);
	fclose (f);
	return NULL;
    }

    uint32_t width = png_get_image_width (png_ptr, info_ptr);
    uint32_t height = png_get_image_height (png_ptr, info_ptr);

#if 0
    // not sure whether RGB rounds to 4B, but ... shouldn't need
    // to care anyway
    /* # bytes/row for 32-bit RGBA should always be 4x width... */
    if (4 * width != png_get_rowbytes (png_ptr, info_ptr)) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", 
			     "%s curious rowbytes value", path);
	fclose (f);
	return NULL;
    }
#endif
    if (PNG_COLOR_TYPE_RGB == colorType) {
        png_set_add_alpha (png_ptr, 0xFF, PNG_FILLER_AFTER);
    }

    if (MAX_PNG_HEIGHT < height) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", 
			     "%s is too tall (%d pixels)", path, height);
	fclose (f);
	return NULL;
    }

    uint32_t i;
    uint8_t* img;

    if (NULL == (img = (uint8_t*)malloc (4 * height * width))) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", 
			     "malloc failed for %s", path);
	fclose (f);
	return NULL;
    }

    for (i = 0; height > i; i++) {
        row_pointers[i] = &img[4 * i * width];
    }

    png_read_image (png_ptr, row_pointers);
    png_read_end (png_ptr, NULL);

    fclose (f);

    return img;
}

static Surface*
readPNGAsset (AAssetManager* mngr, const char* path)
{
    /* 
     * libPNG objects to having these reused for different images;
     * maybe could reuse, but ... not going to bother --SSL
     */
    Surface*    s        = NULL;
    png_structp png_ptr  = NULL;
    png_infop   info_ptr = NULL;
    
    if (NULL == (s = new Surface ()) ||
        NULL == (png_ptr = png_create_read_struct 
			       (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)) ||
	NULL == (info_ptr = png_create_info_struct (png_ptr))) {
	__android_log_print (ANDROID_LOG_INFO, "WALY", 
			     "PNG alloc failed for %s", path);
	if (NULL != s) {
	    delete s;
	}
	if (NULL != png_ptr) {
	    png_destroy_read_struct (&png_ptr, NULL, NULL);
	}
        return NULL;
    }
    uint8_t* img = readPNGAsset_worker (mngr, path, png_ptr, info_ptr);
    if (NULL == img) {
        delete s;
	s = NULL;
    } else {
	s->w = png_get_image_width (png_ptr, info_ptr);
	s->h = png_get_image_height (png_ptr, info_ptr);
	s->format = &s->sfmt;
	// oh, mask should depend on endianness...!
	// ENDIANNESS
	s->format->Amask = 0xFF000000;
	s->format->alpha = 255;
	s->pixels = img;
	s->pitch = s->w * 4;
	s->clipRect.x = 0;
	s->clipRect.y = 0;
	s->clipRect.w = s->w;
	s->clipRect.h = s->h;
	// buffer should never be used for images, so no init...
    }
    png_destroy_read_struct (&png_ptr, &info_ptr, NULL);

    return s;
}

}


#endif // defined(WALY_TARGET_ANDROID)
